---
title: "Replication 4"
author: "Enxhi Buxheli"
date: "4/2/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(dplyr)
library(tidyverse)
library(ei) 
library(MatchIt)
library(weights)
library(simpleboot)
library(Zelig)
library(apsrtable)
```

```{r config}
# Graphics parameters to make output pretty
ylims = c(-.35,.1)
ylims.2 = c(-.45,.1)
xlims = c(.5,11)
dists = seq(from = 1000, to = 100, by = -100) ###DELETE THIS LATER
xs = seq(1:length(dists))
ys = seq(from = -.35, to = .1, by = .05)
ys.lab = c('-0.35','-0.30', '-0.25','-0.20','-0.15','-0.10','-0.05','0.00','0.05','0.10')
ys.2 = seq(from = -.45, to = .1, by = .05)
ys.lab.2 = c('-0.45','-0.40','-0.35','-0.30', '-0.25','-0.20','-0.15','-0.10','-0.05','0.00','0.05','0.10')

offsets = .15
text.offsets = .025
cex.axis = .9
cex.N = .7
top.text.adj = c(1.3,1.3) ##offsets on labels to reduce crowding
bottom.text.adj = c(-.15,-.85)
point.size = 2
line.offset = .0175
```

# Figure 1: Treatment Effects
```{r fig1, cache = TRUE}
# Reading in the necessary csv files to be used in figure 1
wtreat <- read_csv('dataverse_files/white.treat.effect.mean.boot.csv') 
wtreat.lower <- read_csv('dataverse_files/white.treat.effect.conf.boot.lower.csv') 
wtreat.upper <- read_csv('dataverse_files/white.treat.effect.conf.boot.upper.csv') 
Nwtreat <- read_csv('dataverse_files/white.treat.N.csv')
btreat <- read_csv('dataverse_files/black.treat.effect.mean.boot.csv') 
btreat.lower <- read_csv('dataverse_files/black.treat.effect.conf.boot.lower.csv') 
btreat.upper <- read_csv('dataverse_files/black.treat.effect.conf.boot.upper.csv') 
Nbtreat <- read_csv('dataverse_files/black.treat.N.csv')

# Making the read in data usable
use.wtreat  <- as.matrix(wtreat[7,])
use.wlower  <- as.matrix(wtreat.lower[7,])
use.wupper  <- as.matrix(wtreat.upper[7,])
use.Nwtreat <- as.matrix(Nwtreat[7,])
use.btreat  <- as.matrix(btreat[7,])
use.blower  <- as.matrix(btreat.lower[7,])
use.bupper  <- as.matrix(btreat.upper[7,])
use.Nbtreat <- as.matrix(Nbtreat[7,])

# Setting the parameters for the plot
par(las = 1,
    mar = c(5.1, 4.1, .5, .5), 
    cex = cex.N)
plot(xs, use.wtreat,
    ylim = ylims,
    xlim = xlims,
    type = 'n',
    ylab = 'Treatment Effect',
    xlab = 'Treated Group Distance from Projects',
    xaxt = 'n',
    yaxt = 'n.csv')
abline(h = 0, lty = 2)

# Don't really know what these lines do or the function used to create them.
###draw lines first because I want them to be covered by points
###create spaces in lines using the offset (this allows the N to be displayed with the text() function)
##black lines are offset to the left, white lines to the right    

segments(x0= xs[1:2]+offsets, x1 = xs[1:2]+offsets, ##only do it for low N blacks because otherwise lines look funny
    y0 = use.btreat[,1:2], y1 = use.blower[,1:2])
segments(x0= xs[1:2]+offsets, x1 = xs[1:2]+offsets,
    y0 = use.btreat[,1:2] + line.offset,y1 = use.bupper[,1:2])
##now the others
segments(x0= xs[3:10]+offsets, x1 = xs[3:10]+offsets,
    y0 = use.blower[,3:10], y1 = use.bupper[,3:10])
    
segments(x0= xs-offsets, x1 = xs-offsets, ##bottomlines
    y0 = use.wtreat - line.offset, y1 = use.wlower)
segments(x0= xs-offsets, x1 = xs-offsets, ##toplines
    y0 = use.wtreat, y1 = use.wupper)

##points and N descriptions
# Used for creating the points and counts in black
points(xs-offsets, use.wtreat,
       cex = point.size,
       pch = 21, 
       bg = 'white')
text(xs-offsets,use.wtreat,
     paste('(',use.Nwtreat,')',sep = ''),
     cex = cex.N,
     pos = 1)

# Used for creating the points and counts in black
points(xs+offsets, use.btreat,
       pch = 16,
       cex = point.size)
text(xs+offsets,use.btreat,
     paste('(',use.Nbtreat,')',sep = ''),
     cex = cex.N,
     pos = 3)

# Setting the axis in place
axis(side = 1,
     at = xs,
     label = seq(100,1000,100),
     cex.axis = cex.axis)
axis(side = 2,
     at = ys,
     label = ys.lab,
     cex.axis = cex.axis)
```
*Note*: Difference-in-differences results for treatment groups defined by increasing distance from the demolished projects. Differences are for the mean turnout in 2004 minus the mean turnout in 2000 for the treatment group minus the same difference for the control group. White circles represent the mean effect on white voters; black circles represent the mean effect on black voters. The N in each treatment group is in parentheses next to the mean effect. Vertical lines represent the 95% confidence intervals generated by bootstrapped standard errors of the difference between treatment and control.

# Figure 2: Treatment Effects Using Matched White Voters Near Nondemolished Projects for Control Group
```{r fig2, cache=TRUE}
# Reading in the data for figure 2
treat <- read_csv('dataverse_files/white.match.nondemolished.csv')
diffs <- read_csv('dataverse_files/white.match.nondemolished.diffs.csv')

# This specified the shape of the points. In this case, triangles.
# This applies for both fig2 and fig3.
pchs <- 17

# Setting the axis limits. This applies for both fig2 and fig3.
use.ylims  <- ylims
use.ys.lab <- ys.lab
use.ys     <- ys

# Assigning the values to be plotted
## This is the triangle plotted
use.treat   <- treat$coefficient	

## This is the N shown.
use.N.treat <- treat$N.treatment + treat$N.control

## These are the confidence interval calculations
clower <- use.treat-(1.96*treat$stdev)
cupper <- use.treat+(1.96*treat$stdev)


# Outputting the plot with some formatting options specified
par(las = 1, mar = c(5.1, 4.1, .5, .5), cex = cex.N)
plot(xs, use.treat,
     ylim = use.ylims,
     xlim = xlims,
     type = 'n',
     ylab = 'Treatment Effect',
     xlab = 'Treated Group Distance from Projects',
     xaxt = 'n',
     yaxt = 'n')
abline(h = 0, lty = 2)
	
# Draws the confidence intervals
segments(x0 = xs, x1 = xs,
         y0 = use.treat + line.offset, y1 = cupper)
segments(x0 = xs, x1 = xs,
         y0 = use.treat, y1 = clower)

### Treatment Effects
# Creates white space for the count
points(xs, use.treat, 
       pch = pchs, cex = point.size,
       bg = 'white', col = 'black')

# Writes the count on the plot
text(xs,use.treat,
     paste('(',use.N.treat,')',sep = ''),
     pos = 3,
     cex = cex.N)

# Formats the axes
## Formatting the x-axis
axis(side = 1,
		at = xs,
		label = seq(100,1000,100),
		cex.axis = cex.axis)

## Formatting the y-axis
axis(side = 2,
		at = use.ys,
		label = use.ys.lab,
		cex.axis = cex.axis)
```
*Note*: Coefficients on treatment as defined by increasing distance from the demolished projects from OLS regressions on change in turnout from 2000 to 2004 (triangles). N for the regression using matched groups is next to the point representing the coefficient. The treatment group is matched to a control group of white voters living near projects that were not demolished, using nearest neighbor matching. Regressions include variables used in matching as controls. Vertical lines represent the 95% confidence intervals generated by bootstrapped standard errors on the treatment coefficient.

# Figure 3: Treatment Effects Using Matched Black Control Groupand Controlling for Homeownership
```{r fig3, cache=TRUE}
# Reading in the data for figure 3
treat <- read_csv('dataverse_files/white.match.black.property.csv')
diffs <- read_csv('dataverse_files/white.match.black.diffs.property.csv')

# Assigning the values to be plotted
## This is the triangle plotted
use.treat   <- treat$coefficient	

## This is the N shown
use.N.treat <- treat$N.treatment + treat$N.control

## These are the confidence interval calculations
clower <- use.treat-(1.96*treat$stdev)
cupper <- use.treat+(1.96*treat$stdev)


# Outputting the plot with some formatting options specified
par(las = 1, mar = c(5.1, 4.1, .5, .5), cex = cex.N)
plot(xs, use.treat,
     ylim = use.ylims,
     xlim = xlims,
     type = 'n',
     ylab = 'Treatment Effect',
     xlab = 'Treated Group Distance from Projects',
     xaxt = 'n',
     yaxt = 'n')
abline(h = 0, lty = 2)
	
# Draws the confidence intervals
segments(x0 = xs, x1 = xs,
         y0 = use.treat + line.offset, y1 = cupper)
segments(x0 = xs, x1 = xs,
         y0 = use.treat, y1 = clower)

### Treatment Effects
# Creates white space for the count
points(xs, use.treat, 
       pch = pchs, cex = point.size,
       bg = 'white', col = 'black')

# Writes the count on the plot
text(xs,use.treat,
     paste('(',use.N.treat,')',sep = ''),
     pos = 3,
     cex = cex.N)

# Formats the axes
## Formatting the x-axis
axis(side = 1,
		at = xs,
		label = seq(100,1000,100),
		cex.axis = cex.axis)

## Formatting the y-axis
axis(side = 2,
		at = use.ys,
		label = use.ys.lab,
		cex.axis = cex.axis)
```
*Note*: Coefficients on treatment as defined by increasing distance from the demolished projects from OLS regressions on change in turnout from 2004 to 2000 (triangles). N for the regression using matched groups is next to the point representing the coefficient. The white treatment group is matched to a black control group of the same N using nearest neighbor matching and including variables on homeownership and home value. Regressions include variables used in matching as controls. Vertical lines represent the 95% confidence intervals generated by bootstrapped standard errors on the treatment coefficient.

# Figure 4: Effects of Distance and Size of Projects
## Figure 4a
```{r fig4a}
# predicted effects graphs
# Reading in the data for figure 4. This needs to be read.csv so it isn't read
# in as a tibble but instead as a list for plottability. Renaming as well for 
# the code to execute.
# Figure 4a data
distdat <- read.csv('dataverse_files/predicted.results.distance.vary.context.csv')
colnames(distdat) <- c("mean","sd","50%","2.5%","97.5%")

# new ylims for these graphs
ylims.predict <- c(.6,.75)

# Creating figure 4a
xs_a <- seq(from = 10, to = 2000, by = 10)
# Setting the parameters
par(las = 1, mar = c(3, 4, .1, .1), mai = c(1.22,0.82,0.82,0.1))

# Plot of the mean [solid line]
plot(xs_a, distdat[,'mean'],
     type = 'l',
     xlab = 'Distance from Project',
     ylab = expression(Pr(vote[2004])),
     ylim = ylims.predict,
     xaxt = 'n',
     cex.axis = cex.axis,
     lwd = 4)

# Adding gridlines to the plot
abline(h = seq(from = min(ylims.predict), to = max(ylims.predict), by = .025),
       lty = 2,
       col = 'gray',
       lwd = 1)
abline(v = seq(from = 0, to = 2000, by = 200),
       lty = 2,
       col = 'gray',
       lwd = 1)

# Dotted lines showing the confidence interval range from mean
lines(xs_a, distdat[,"2.5%"],
      lty = 3,
      lwd = 2.5)
lines(xs_a, distdat[,'97.5%'],
      lty = 3,
      lwd = 2.5)

# Labelling the axis
axis(side = 1,
     at = seq(from = 0, to = 2000, by = 200),
     labels = as.character(seq(from = 0, to = 2000, by = 200)),
     cex.axis = cex.axis)
```

## Figure 4b
```{r fig4b}
# predicted effects graphs
# Reading in the data for figure 4. This needs to be read.csv so it isn't read
# in as a tibble but instead as a list for plottability. Renaming as well for 
# the code to execute.

#Figure 4b data
areadat <- read.csv('dataverse_files/predicted.results.area.vary.context.csv')
colnames(areadat) <- c("mean","sd","50%","2.5%","97.5%")

# Creating figure 4b
xs_b   <- seq(from = 45000, to = 1004000, by = 4800)/1000
# Setting the parameters
par(las = 1, mar = c(4, 4, .1, .1), mai = c(1.22,0.82,0.82,0.1))

# Plot of the mean [solid line]
plot(xs_b, areadat[,'mean'],
     type = 'l',
     xlab = 'Percent of Local Black Population in Demolished Project',
     ylab = expression(Pr(vote[2004])),
     ylim = ylims.predict,
     xaxt = 'n',
     cex.axis = cex.axis,
     lwd = 4)

# Adding gridlines to the plot
abline(h = seq(from = min(ylims.predict), to = max(ylims.predict), by = .025),
       lty = 2,
       col = 'gray',
       lwd = 1)
abline(v = seq(from = 0, to = 2000, by = 200),
       lty = 2,
       col = 'gray',
       lwd = 1)

# Dotted lines showing the confidence interval range from mean
lines(xs_b, areadat[,"2.5%"],
      lty = 3,
      lwd = 2.5)
lines(xs_b, areadat[,'97.5%'],
      lty = 3,
      lwd = 2.5)

# Labelling the axis
axis(side = 1,
     at = seq(from = 0, to = 1000, by = 100),
     labels = as.character(c('0','10%','20%','30%','40%','50%','60%','70%','80%','90%','100%')),
     cex.axis = cex.axis)
```
*Figure 4 Note*: Predicted effects generated from $vote_{2004} = \beta_0 + \beta_1 (\log(\text{distance})) + \beta_2 (\log(\text{local percent})) + vote_{2000}$, with white voters. Figure 4(a) is the predicted probability that a person who voted in 2000 will vote in 2004 with increasing distance, while holding size at its mean. Figure 4(b) is the predicted probability that a person who voted in 2000 will vote in 2004, with increasing outgroup population size, with $distance = 100$. Dotted lines represent 95% confidence intervals generated by bootstrapped standard errors.

```{r}
# ###########################################
# ###vote choice graphs################
# ###Figures 5 and 6
# ###################################
# pres.elections = c('dole_pct_ei','bush2000_pct_ei','bush2004_pct_ei','mccain_pct_ei')
# obama.elections = c('obama_sen_primary_pct_ei','keyes_pct_ei','obama_pres_primary_pct_ei')
# 
# dists = read.csv('dataverse_files/distance.vote.differences.csv')
# demos = read.csv('dataverse_files/demolished.vote.differences.csv')
# 
# 
# graphs = c('5a','5b','6')
# 
# for(i in graphs){
# 
# 	if(i == '5a'){dat = dists}
# 	else{dat = demos}
# 		
# 	if(i %in% c('5a','5b')){
# 		xlims = c(.75,4.25)
# 		ylims = c(-.1,.2)	
# 		}
# 	else{
# 		xlims = c(.75,3.25)
# 		ylims = c(-.1,.25)
# 		}
# 
# 	##recode Keyes to Obama general for presentation purposes
# 	dat[dat$election == 'keyes_pct_ei','x.mean'] = 1 - dat[dat$election == 'keyes_pct_ei','x.mean']
# 	dat[dat$election == 'keyes_pct_ei','y.mean'] = 1 - dat[dat$election == 'keyes_pct_ei','y.mean']
# 	dat[dat$election == 'keyes_pct_ei','diff'] =dat[dat$election == 'keyes_pct_ei','y.mean'] - dat[dat$election == 'keyes_pct_ei','x.mean']
# 	
# 		pdf(paste('output/Figure_',i,'.pdf',sep=''),
# 		width = 7, height = 8)
# 		par(las = 1)
# 		par(mar = c(5.1, 4.1, .5, 1.5))
# 		plot(seq(1:4),
# 			rep(1,4),
# 			ylim = ylims,
# 			xlim = xlims, 
# 			type = 'n',
# 			xaxt = 'n',
# 			yaxt = 'n',
# 			xlab = 'Election',
# 			ylab = ifelse(i == '5b','','Treatment Effect')
# 			)
# 		abline(h=0, lty = 2)
# 		
# 		if(i %in% c('5a','5b')){
# 			segments(
# 				x0= seq(1:4)-offsets, 
# 				x1 = seq(1:4)-offsets,
# 				y0 = dat[dat$group == 'white'&dat$election %in% pres.elections,'diff']-(1.96*dat[dat$group == 'white'&dat$election %in% pres.elections,'sd']),
# 				y1 =	dat[dat$group == 'white'&dat$election %in% pres.elections,'diff']+(1.96*dat[dat$group == 'white'&dat$election %in% pres.elections,'sd'])	
# 					)
# 			points(seq(1:4)-offsets,
# 				dat[dat$group == 'white'&dat$election %in% pres.elections,'diff'],
# 					pch = 21, 
# 					bg = 'white',
# 					col = 'black',
# 					cex = 2
# 				)
# 			segments(
# 				x0= seq(1:4)+offsets, 
# 				x1 = seq(1:4)+offsets,
# 				y0 = dat[dat$group == 'black'&dat$election %in% pres.elections,'diff']-(1.96*dat[dat$group == 'black'&dat$election %in% pres.elections,'sd']),
# 				y1 =	dat[dat$group == 'black'&dat$election %in% pres.elections,'diff']+(1.96*dat[dat$group == 'black'&dat$election %in% pres.elections,'sd'])	
# 					)
# 			points(seq(1:4)+offsets,
# 				dat[dat$group == 'black'&dat$election %in% pres.elections,'diff'],
# 					pch = 16,
# 					cex = 2
# 				)
# 			axis(side = 1, at = seq(1:4), 
# 				c('1996','2000','2004','2008'), 
# 				tick = F,
# 				cex.axis = cex.axis)		
# 			}
# 		else{
# 			segments(
# 				x0= seq(1:3)-offsets, 
# 				x1 = seq(1:3)-offsets,
# 				y0 = dat[dat$group == 'white'&dat$election %in% obama.elections,'diff']-(1.96*dat[dat$group == 'white'&dat$election %in% obama.elections,'sd']),
# 				y1 =	dat[dat$group == 'white'&dat$election %in% obama.elections,'diff']+(1.96*dat[dat$group == 'white'&dat$election %in% obama.elections,'sd'])	
# 					)
# 			points(seq(1:3)-offsets,
# 				dat[dat$group == 'white'&dat$election %in% obama.elections,'diff'],
# 					pch = 21, 
# 					bg = 'white',
# 					col = 'black',
# 					cex = 2
# 				)
# 			segments(
# 				x0= seq(1:3)+offsets, 
# 				x1 = seq(1:3)+offsets,
# 				y0 = dat[dat$group == 'black'&dat$election %in% obama.elections,'diff']-(1.96*dat[dat$group == 'black'&dat$election %in% obama.elections,'sd']),
# 				y1 =	dat[dat$group == 'black'&dat$election %in% obama.elections,'diff']+(1.96*dat[dat$group == 'black'&dat$election %in% obama.elections,'sd'])	
# 					)
#   			points(seq(1:3)+offsets,
# 				dat[dat$group == 'black'&dat$election %in% obama.elections,'diff'],
# 					pch = 16,
# 					cex = 2
# 				)
# 		axis(side = 1, at = seq(1:3), 
# 					c('2004 \n Senate Primary','2004 \n Senate General','2008 \n President Primary'),
# 					tick = F,
# 					cex.axis = cex.axis
# 					)
# 		
# 			}	
# 		axis(side = 2,
# 			at = seq(from = -.1, to = .3, by = .05),
# 			label = c('-0.10','-0.05','0.00','0.05','0.10','0.15','0.20','0.25','0.30'),
# 			cex.axis = cex.axis
# 			)			
# 		dev.off()
# 	}		
# 				
# 
# ###########################################
# ###parallel trends graph################
# ###Appendix Figures A2
# ###################################
# 
# groups = read.csv('dataverse_files/par.trends.csv')
# 
# 
# ###plot elections votes
# 	pdf('appendix_output/Figure_A2.pdf')
# 		par(las = 1)
# 		par(mar = c(5.1, 4.1, .5, .5))
# 		plot(1,
# 			.5,
# 			ylim = c(.5,.9),
# 			xlim = c(1,5),
# 			type = 'n',
# 			xaxt = 'n',
# 			ylab = 'Percent Voter Turnout',
# 			xlab = 'Year'
# 			)
#  			text(seq(1:5),groups[,'white.control'], expression('W'['C']), cex = 1.5)
# 			text(seq(1:5),groups[,'white.treatment'],expression('W'['T']), cex = 1.5)
# 			text(seq(1:5),groups[,'black.control'], expression('B'['C']), cex = 1.5)
# 			text(seq(1:5),groups[,'black.treatment'],expression('B'['T']), cex = 1.5)
# 				
# 			lines(seq(1:5),groups[,'white.control'], lty = 2)
# 			lines(seq(1:5),groups[,'white.treatment'], lty = 2)
# 			lines(seq(1:5),groups[,'black.control'], lty = 2)
# 			lines(seq(1:5),groups[,'black.treatment'], lty = 2)
# 
# 		axis(side = 1, at = seq(1:5), labels = c('1996','1998','2000','2002','2004'))
# 		axis(side = 2, at = seq(from = .5, to = .9, by = .05), labels = seq(from = .5, to = .9, by = .05))
# 			
# 		dev.off()
```


